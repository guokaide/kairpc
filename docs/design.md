# 一. 基本概念
## 什么是 RPC?
RPC (Remote Procedure Call) 即远程过程调用，是一种计算机通信协议，规定了不同计算机进程间通信和交互的约定，可以让远程方法像本地方法一样调用。
## 为什么需要 RPC?
假设我们有 2 个系统：外卖平台和订单中心。当用户在外卖平台下单的时候，会调用订单中心的接口，生成订单。
如果没有 RPC 的话，我们调用的过程是这样的：
```java
url = "http://ordercenter/order";
request = new Request(参数 1,参数 2,参数 3);
response = httpClient.post(url).body(request).execute();
orderId = respnse.data;
```

而如果有了 RPC 框架，我们就可以像调用本地方法一样调用这个接口，一句代码搞定：
```java
orderId = orderService.order(参数 1，参数 2，参数 3);
```

我们会发现，第一种方式需要构造 http 请求体，然后通过 http 客户端发起请求。
而使用 RPC 框架无需关注请求体如何构造，请求如何发起，非常简单。

对比以上两种方式，我们可以看出，RPC 框架的优势在于：

- **屏蔽了远程调用和本地调用的区别**。调用远程方法就像调用本地方法一样。
- **屏蔽了网络通信的复杂性**。我们无需关注系统间是如何进行网络通信的，RPC 框架会帮我们处理，我们可以更加专注于业务逻辑的开发。
# 二. RPC 框架的实现思路
## 基本设计
“哪有什么岁月静好，不过是有人替你负重前行”。RPC 能如此方便地使用，一定做了很多的工作。

接下来，我们看看，RPC 框架是如何做到屏蔽了网络通信的细节，让我们可以像调用本地方法一样调用远程方法呢？

RPC 框架中有 2 个核心角色：

- **服务提供者**：对外提供服务
- **服务消费者**：调用服务提供者提供的服务

服务提供者会启动 Web 服务，服务消费者会通过请求客户端发送请求（HTTP 协议或者其它协议），调用服务提供者提供的不同服务。

Web 服务器的选择有很多，比如说 SpringBoot 内嵌的 Tomcat、NIO 框架 Netty 和 Vert.x，或者也可以像 Kafka 集群一样，采用 Java 原生的 NIO 实现 Web 服务器。

比如说，服务提供者：订单中心提供了一个下单的接口，服务消费者：外卖平台可以通 [http://ordercenter/order](http://ordercenter/order) 这个接口可以通过 HTTP 客户端调用 orderService 的 order 方法。

![](https://cdn.nlark.com/yuque/0/2024/jpeg/120406/1710892328206-0a04e7c9-f3d9-4e6e-b22e-18210e14d7a9.jpeg)

但是，服务提供者可能提供了多个不同的接口和方法，在 Rest 服务中，服务提供者可能需要提供多个不同的 Rest 接口，服务消费者要针对不同的接口，构造不同的参数以及 HTTP 请求，这就很麻烦。

那如何简化呢？

我们可以构建统一的**请求处理器**，提供统一的服务调用接口，根据请求客户端的请求参数，分发不同的请求，调用不同的接口和服务，然后通过反射实现调用，最后封装响应并返回。

我们可以提供一**个服务器存根（skeleton）**，存储服务提供者对外提供服务的接口和方法，相当于一个本地注册器。

比如说，服务消费者要调用 orderServie 服务的 order 方法，可以通过请求客户端发送请求，请求参数如下，然后请求处理器会根据 service 名称在服务器存根找到对应的服务实现类，然后通过反射机制调用 method 指定的方法。
```java
{
	"service": "orderService",
	"method": "order"
}
```

![](https://cdn.nlark.com/yuque/0/2024/jpeg/120406/1710975488564-35080989-29b6-4173-a9f6-31adcfb79599.jpeg)

现在，服务提供者只需对外暴露一个接口，就可以处理不同的服务请求，服务消费者也可以写一套请求处理逻辑，即可发起服务调用，但是还有一个问题没有解决：服务消费者调用接口的时候，仍然需要写一大段请求客户端的逻辑。

那如何简化呢？

我们可以基于代理模式，为服务消费者要调用的接口生成一个代理对象，由代理对象实际完成发起请求和处理响应的过程，这样的话，服务消费者调用接口的时候，就像调用本地接口一样，无需知道请求处理的逻辑。

常见的动态代理的实现方式有 JDK 动态代理、基于字节码生成的动态代理（如 CGLIB）。前者简单易用，无需引入额外的库，缺点是只能对接口进行代理；后者更加灵活，可以对任何类进行代理，但是性能略低于 JDK 动态代理。

我们可以在服务消费者提供一个**本地存根（stub）**，用于缓存接口和其代理对象的信息。

由于网络中只能传输二进制流，而无法传输 Java 对象，所以服务消费者发起请求的时候，要对传输的请求进行序列化，服务提供者收到请求之后，要对收到的请求进行反序列化。

常见的序列化方式有 Java 原生序列化、JSON、Hessian、Kryo、protobuf 等。

以下就是一个 RPC 框架的基本架构，其中虚线部分就是 RPC 架构。

![](https://cdn.nlark.com/yuque/0/2024/jpeg/120406/1710975488587-feb4d1f3-0eed-408c-9e88-b5e74fca192b.jpeg)

## 扩展设计
### 服务发现
服务消费者要调用服务提供者的服务，必须要知道服务提供者的地址，那消费者是如何知道服务提供者的地址呢？

RPC 框架可以提供服务注册和发现的能力，这正是**注册中心**的职责。

服务提供者可以将提供服务的实例注册到注册中心，服务消费者去注册中心查询服务提供者的地址即可。

一般注册中心可以通过 ZooKeeper，Redis 或者 etcd 等中间件实现。

另外还需要注意两个问题：

- 当服务提供者异常下线了，注册中心要及时更新提供者信息，并且通知消费者，消费者要根据通知，更新可以调用的提供者实例。
- 消费者如果每次调用都要从注册中心拉取数据，一方面会影响性能，另一方面对注册中心的压力太大。因此，为了提高性能，消费者应该尽缓存消费者实例，当注册中心数据变更时，通知消费者更新信息即可。
### 负载均衡
一般服务提供者会有多个实例提供服务，那服务消费者应该选择哪个实例呢？

RPC 框架可以提供负载均衡的能力，通过负载均衡策略决定消费者选择哪个实例处理请求。

常用的负载均衡算法有随机，轮询，加权，自适应等。
### 容错机制
消费者在调用提供者的服务的时候，可能会调用失败，那应该如何处理失败呢？

为了保证分布式系统是高可用的，RPC 框架需要具备一定的容错机制，比如说，失败重试，降级处理等。
### 传输协议
网络传输请求和响应的过程中，选择不同的协议以及传输的数据量，对性能的影响不同。

一般而言，TCP 的性能要由于 HTTP 协议，所以多数 RPC 框架选择 TCP 协议。

同时 ，为了降低 RPC 请求的数据量，也有框架会采用自定义 RPC 协议，以及压缩请求。

当然，自定义 RPC 协议就需要考虑向前和向后兼容的问题。

此外，不同的序列化方式性能也不同，因此选择合适的序列化方式也会影响性能。
### 可扩展性
对于一个 RPC 框架而言，其中的每一个组件都可能有不满足业务需求的情形，因此，需要考虑框架本身的扩展性问题。

为了提高扩展性，RPC 框架可以考虑支持插件化，可配置等。

比如说，抽象接口，提供默认实现，并且支持不同的扩展实现。

比如说，支持 Java 的 SPI 机制，让用户可以自行扩展实现。

RPC 框架的实现，涉及到网络传输及优化，代理机制，序列化，服务注册和发现，负载均衡，容错处理以及可扩展性等等。

